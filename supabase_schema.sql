-- 1a. Create BRANCHES table
create table public.branches (
  id bigint generated by default as identity primary key,
  name text not null,
  location text,
  manager_name text,
  manager_phone text,
  status text default 'Active',
  created_at timestamptz default now()
);

-- 1b. Create PROFILES table (Extends Auth)
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  full_name text,
  role text default 'Collector', -- 'Super Admin', 'Supervisor', 'Collector', 'Manager'
  phone text,
  district text,
  branch_id bigint references public.branches(id), -- Linked Branch
  status text default 'active', -- 'active', 'blocked'
  daily_target numeric default 0,
  created_at timestamptz default now()
);

-- 2. Create CUSTOMERS table (The main data)
create table public.customers (
  id bigint generated by default as identity primary key,
  sqn text unique not null, -- Sequence Number (ID)
  name text not null,
  phone text,
  district text,
  balance numeric default 0,
  prev_balance numeric default 0,
  total_due numeric generated always as (balance + prev_balance) stored,
  status text default 'Normal', -- 'Normal', 'Balan', 'Discount', 'Paid', 'Inactive'
  fahfahin text, -- Notes
  discount_amount numeric default 0,
  appointment_date timestamptz, -- For 'Balan'
  paid_date timestamptz, -- When marked as Paid
  assigned_to uuid references public.profiles(id), -- Collector ID
  location_lat float,
  location_lng float,
  is_favorite boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- 3. Create ACTIVITY_LOGS table (For Reports/Dashboard)
create table public.activity_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id),
  action_type text, -- 'login', 'call', 'payment', 'discount', 'edit'
  customer_sqn text references public.customers(sqn),
  details jsonb, -- Flexible details (e.g. { amount: 50, note: 'Paid' })
  timestamp timestamptz default now()
);

-- 4. Enable Row Level Security (RLS) - Security Best Practice
alter table public.profiles enable row level security;
alter table public.customers enable row level security;
alter table public.activity_logs enable row level security;
alter table public.branches enable row level security;

-- 5. Create Policies (Simplified for Initial Setup)

-- PROFILES: Everyone can read profiles (needed for assigning tasks), Users can update their own
create policy "Public profiles are viewable by everyone"
  on profiles for select
  using ( true );

create policy "Users can update own profile"
  on profiles for update
  using ( auth.uid() = id );

-- CUSTOMERS: Authenticated users can read all (for now). 
-- In future: Collectors only see their district/assigned.
create policy "Authenticated users can view customers"
  on customers for select
  using ( auth.role() = 'authenticated' );

create policy "Authenticated users can update customers"
  on customers for update
  using ( auth.role() = 'authenticated' );

create policy "Authenticated users can insert customers"
  on customers for insert
  with check ( auth.role() = 'authenticated' );

-- LOGS: Insert allowed for auth users, Select for Supervisor/Admin (implied by logic later)
create policy "Users can insert logs"
  on activity_logs for insert
  with check ( auth.uid() = user_id );

create policy "Users can view logs"
  on activity_logs for select
  using ( auth.role() = 'authenticated' );

-- BRANCHES: Authenticated can view (to select branch), Admins can update
create policy "Authenticated can view branches"
  on branches for select
  using ( auth.role() = 'authenticated' );

create policy "Admins can insert branches"
  on branches for insert
  with check ( auth.role() = 'authenticated' ); --Ideally check profile role='Super Admin' using a lookup, but simplified for now

create policy "Admins can update branches"
  on branches for update
  using ( auth.role() = 'authenticated' );


-- 6. Trigger to automatically create profile on signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, role)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', coalesce(new.raw_user_meta_data->>'role', 'Collector'));
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
